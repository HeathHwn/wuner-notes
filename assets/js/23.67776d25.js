(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{333:function(v,t,a){v.exports=a.p+"assets/img/1.dce12c2d.png"},334:function(v,t,a){v.exports=a.p+"assets/img/2.21e109b3.png"},551:function(v,t,a){"use strict";a.r(t);var _=a(18),r=Object(_.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"v8-javascript-执行引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-javascript-执行引擎"}},[v._v("#")]),v._v(" V8(JavaScript 执行引擎)")]),v._v(" "),_("ul",[_("li",[v._v("V8 引擎是一个 JavaScript 引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。")]),v._v(" "),_("li",[v._v("V8 使用 C++开发，在运行 JavaScript 之前，相比其它的 JavaScript 的引擎转换成字节码或解释执行，V8 将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。")]),v._v(" "),_("li",[v._v("有了这些功能，JavaScript 程序在 V8 引擎下的运行速度媲美二进制程序。")]),v._v(" "),_("li",[v._v("V8 支持众多操作系统，如 windows、linux、android 等，也支持其他硬件架构，如 IA32,X64,ARM 等，具有很好的可移植和跨平台特性。")])]),v._v(" "),_("h2",{attrs:{id:"内存管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[v._v("#")]),v._v(" 内存管理")]),v._v(" "),_("h3",{attrs:{id:"v8-内存限制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-内存限制"}},[v._v("#")]),v._v(" V8 内存限制")]),v._v(" "),_("blockquote",[_("p",[v._v("限制大小")])]),v._v(" "),_("p",[v._v("64 位为 1.4GB，32 位为 0.7GB")]),v._v(" "),_("blockquote",[_("p",[v._v("限制原因")])]),v._v(" "),_("p",[v._v("V8 之所以限制了内存的大小，表面上的原因是 V8 最初是作为浏览器的 JavaScript 引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于 V8 的垃圾回收机制的限制。由于 V8 需要保证 JavaScript 应用逻辑与垃圾回收器所看到的不一样，V8 在执行垃圾回收时会阻塞 JavaScript 应用逻辑，直到垃圾回收结束再重新执行 JavaScript 应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若 V8 的堆内存为 1.5GB，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式的垃圾回收甚至要 1 秒以上。这样浏览器将在 1s 内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。")]),v._v(" "),_("h3",{attrs:{id:"v8-垃圾回收策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收策略"}},[v._v("#")]),v._v(" V8 垃圾回收策略")]),v._v(" "),_("ul",[_("li",[v._v("采用分代回收的思想")]),v._v(" "),_("li",[v._v("内存分为新生代、老生代")]),v._v(" "),_("li",[v._v("针对新、老生代采用不同算法来提升垃圾回收的效率")])]),v._v(" "),_("p",[v._v("新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。")]),v._v(" "),_("h4",{attrs:{id:"v8-新生代、老生代内存大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-新生代、老生代内存大小"}},[v._v("#")]),v._v(" V8 新生代、老生代内存大小")]),v._v(" "),_("p",[v._v("V8 引擎的新生代内存大小 32MB（64 位）、16MB（32 位），老生代内存大小为 1400MB（64 位）、700MB（ 32 位）。")]),v._v(" "),_("h4",{attrs:{id:"新生代对象回收实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新生代对象回收实现"}},[v._v("#")]),v._v(" 新生代对象回收实现")]),v._v(" "),_("ul",[_("li",[v._v("回收过程采用复制算法+标记整理")]),v._v(" "),_("li",[v._v("新生代内存区被等分为两个空间")]),v._v(" "),_("li",[v._v("使用空间为 From，空闲空间为 To")]),v._v(" "),_("li",[v._v("标记整理后将活动对象拷贝至 To")]),v._v(" "),_("li",[v._v("From 和 To 交换空间完成释放")])]),v._v(" "),_("p",[_("img",{attrs:{src:a(333),alt:"note"}})]),v._v(" "),_("h4",{attrs:{id:"晋升"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#晋升"}},[v._v("#")]),v._v(" 晋升")]),v._v(" "),_("p",[v._v("将新生代对象移到老生代")]),v._v(" "),_("blockquote",[_("p",[v._v("晋升条件")])]),v._v(" "),_("ul",[_("li",[v._v("一轮 GC 还存活的新生代需要晋升")]),v._v(" "),_("li",[v._v("对象从 From 空间复制到 To 空间时，如果 To 空间已经被使用了超过 25%，那么这个对象直接被复制到老生代")])]),v._v(" "),_("h4",{attrs:{id:"老生代对象回收实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#老生代对象回收实现"}},[v._v("#")]),v._v(" 老生代对象回收实现")]),v._v(" "),_("ul",[_("li",[v._v("主要采取标记清除、标记整理、增量标记算法")]),v._v(" "),_("li",[v._v("首先使用标记清除完成垃圾空间的回收")]),v._v(" "),_("li",[v._v("采用标记整理进行空间优化")]),v._v(" "),_("li",[v._v("采用增量标记进行效率优化")])]),v._v(" "),_("h4",{attrs:{id:"细节对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#细节对比"}},[v._v("#")]),v._v(" 细节对比")]),v._v(" "),_("blockquote",[_("p",[v._v("新生代区域，采用复制算法， 因此其每时每刻内部都有空闲空间的存在(为了完成 From 到 To 的对象复制)，但是新生代区域空间较小(32M)且被一分为二，所以这种空间上的浪费也是比较微不足道的。")])]),v._v(" "),_("blockquote",[_("p",[v._v("老生代因其空间较大(1.4G),如果同样采用一分为二的做法则对空间大小是比较浪费，且老生代空间较大，存放对对象也较多，如果进行复制算法，则其消耗对时间也会更大。也就是是否使用复制算法来进行垃圾回收，是一个时间 T 关于内存大小的关系，当内存大小较小时，使用复制算法消耗的时间是比较短的，而当内存较大时，采用复制算法对时间对消耗也就更大。")])]),v._v(" "),_("h4",{attrs:{id:"v8-的优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-的优化"}},[v._v("#")]),v._v(" V8 的优化")]),v._v(" "),_("blockquote",[_("p",[v._v("增量标记")])]),v._v(" "),_("p",[v._v("由于全停顿会造成了浏览器一段时间无响应，所以 V8 使用了一种增量标记的方式，将完整的标记拆分成很多部分，每做完一部分就停下来，让 JS 的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的 1/6 左右")]),v._v(" "),_("p",[_("img",{attrs:{src:a(334),alt:"note"}})]),v._v(" "),_("blockquote",[_("p",[v._v("惰性清理")])]),v._v(" "),_("p",[v._v("由于标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。我们可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。垃圾回收器可以根据需要逐一清理死对象所占用的内存空间")]),v._v(" "),_("blockquote",[_("p",[v._v("其他")])]),v._v(" "),_("p",[v._v("V8 后续还引入了增量式整理（incremental compaction），以及并行标记和并行清理，通过并行利用多核 CPU 来提升垃圾回收的性能")])])}),[],!1,null,null,null);t.default=r.exports}}]);